program1 --> NOP 101 times, then HLT

program2 --> NOP, R0_l-AND-R0_m and Put result in R1_l.
Then R1_l-OR-R1_m and Put result in R2_l.
Then R2_l-AND-R2_m and Put result in R0_l.
Repeat, then HLT.
NOTE: preliminarly load some numbers in R0_l (0xC6), R0_m (0x53), R1_m (0x81), R2_m (0x0F)
Final result:
R0_m: 0x53; R0_l: 0x03
R1_m: 0x81; R1_l: 0x03
R2_m: 0x0F; R2_l: 0x83

program3 --> NOP, R0-AND-R1 and Put result in R2 (16 bit AND).
R0-OR-R1 and Put result in R3 (16 bit OR), then HLT
NOTE: preliminarly load some numbers in R0 and R1
Final result:
R0_m: 0x53; R0_l: 0xF7
R1_m: 0x81; R1_l: 0xA8
R2_m: 0x01; R2_l: 0xA0
R3_m: 0xD3; R3_l: 0xFF

program4 --> NOP, shift left (8bit) R0_l and save in R0_m,
Shift right (8bit) R0_l and save in R1_l,
Aritmetic shift right (8bit) R0_l and save in R1_m.
Then, shift left (16bit) R1 and save in R2,
Shift right (16bit) R1 and save in R4_l,
Aritmetic shift right (16bit) R1 and save in R4_m.
Then, shift left (32bit) R4 and save in R5,
Shift right (32bit) R4 and save in R5,
Aritmetic shift right (32bit) R4 and save in R5, then HLT.
NOTE: preliminarly load some numbers in R0: R0_l: 0xD3
Final result:
R0_m: 0xA6; R0_l: 0xD3
R1_m: 0xE9; R1_l: 0x69
R2_m: 0xD2; R2_l: 0xD2
R4_mh: 0xF4; R4_ml: 0xB4; R4_lh: 0x74; R4_ll: 0xB4;
R5_mh: 0xE9; R5_ml: 0x68; R5_lh: 0xE9; R5_ll: 0x68; (first op)
R5_mh: 0x7A; R5_ml: 0x5A; R5_lh: 0x3A; R5_ll: 0x5A; (second op)
R5_mh: 0xFA; R5_ml: 0x5A; R5_lh: 0x3A; R5_ll: 0x5A; (third op)

program5 --> NOP, then perform:
ADD16 R2=R0+R1
SUB16 R3=R0-R1
ADD32 R5=R4+R5
SUB32 R5=R4-R5
NOTE: operations are with sign!
NOTE2: preliminarly load some numbers in R0,R1,R4,R5:
R0: 3201 0x0C81
R1: 749 0x02ED (if you want to trigger overflow: 32500 0x7EF4 )
R4: 524680 0x00080188
R5: 786364 0x000BFFBC
Final result: 
R2: 3950 0x0F6E (if R1==32500 overflow --> 35701, hence -29835 0X8B75 )
R3: 2452 0x0994 (if R1==32500 --> -29299 0X8D8D )
R5 (1st op): 1311044 0x00140144
R5 (2nd op): -786364 0xFFF40044



